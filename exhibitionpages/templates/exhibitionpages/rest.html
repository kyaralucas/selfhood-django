{% extends "exhibitionpages/base.html" %}
{% load static %}
{% block title %}Digital Resting Space{% endblock %}

{% block content %}
<section class="rest-page">
  <style>
    :root{
      --rest-bg-mobile: url("{% static 'img/blurred_background_mobile.png' %}");
      --rest-bg-desktop: url("{% static 'img/blurred_background.png' %}");
    }
  </style>

  <!-- top row (like screenshot) -->
  <div class="rest-top">
    <div class="rest-kicker rest-kicker--left">SELFHOOD <br class="mobile-only">  ACT II</div>
    <div class="rest-kicker rest-kicker--right" style="text-align: right;">EXHIBITION BY <br class="mobile-only">  AQUEENE WILSON</div>
  </div>

  <!-- center content -->
  <div class="rest-center">
    <div id="restMessage" class="rest-message" aria-live="polite"></div>

    <div id="restQA" class="rest-qa" hidden>
      <div class="rest-qa__q" id="qaQ"></div>
      <div class="rest-qa__a" id="qaA"></div>

      <button class="rest-next" id="nextBtn" type="button">next</button>
    </div>

    <div id="restEmpty" class="rest-empty" hidden>
      No shared answers yet — check back soon.
    </div>
  </div>

  <!-- audio (hidden controls; we’ll show a small helper if autoplay is blocked) -->
  <audio id="restAudio" autoplay loop preload="auto">
    <source src="{% static 'audio/audio.mp3' %}" type="audio/mpeg">
  </audio>

  <button id="audioHelp" class="audio-help" type="button" hidden>
    Tap to play soundscape
  </button>

  {# Safely serialize qas for JS #}
  {{ qas|json_script:"qas-data" }}
</section>


<footer class="rest-footer" role="contentinfo">
    <div class="rest-footer__inner">
      <span>DIRECTION BY AQUEENE WILSON</span>
      <span class="rest-footer__sep">·</span>
      <span>MUSICAL COMPOSITION, ARRANGEMENT AND SONGWRITING DONE BY WATRA</span>
      <span class="rest-footer__sep">·</span>
      <span>PRODUCTION, MIX AND MASTERING BY MARTIN BUITENWEG</span>
      <span class="rest-footer__sep">·</span>
      <span>CO-COMPOSER: TOTO BOROTO</span>
    </div>
  </footer>
  


<script>
  // ---------- helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function waitForTransitionEnd(el, prop = "opacity", fallbackMs = 900) {
  return new Promise(resolve => {
    let done = false;
    const finish = () => {
      if (done) return;
      done = true;
      el.removeEventListener("transitionend", onEnd);
      resolve();
    };

    const onEnd = (e) => {
      if (!e || e.propertyName === prop) finish();
    };

    el.addEventListener("transitionend", onEnd);
    setTimeout(finish, fallbackMs);
  });
}

function forceRepaint(el) {
  // forces WebKit to flush styles
  void el.offsetHeight;
}


  function setFadeText(el, text, {fadeInMs=1200, holdMs=8000, fadeOutMs=1200} = {}) {
    // Returns a promise that resolves after fade-out is complete
    return new Promise(async (resolve) => {
      el.style.transition = `opacity ${fadeInMs}ms ease`;
      el.style.opacity = 0;
      el.textContent = text;

      // trigger fade in
      requestAnimationFrame(() => {
        el.style.opacity = 1;
      });

      await sleep(fadeInMs + holdMs);

      // fade out
      el.style.transition = `opacity ${fadeOutMs}ms ease`;
      el.style.opacity = 0;

      await sleep(fadeOutMs);
      resolve();
    });
  }

  function fadeIn(el, ms=800) {
    el.style.transition = `opacity ${ms}ms ease`;
    el.style.opacity = 0;
    el.hidden = false;
    requestAnimationFrame(() => el.style.opacity = 1);
  }

  function fadeSwap(el, setContentFn, ms=800) {
    // fade out -> swap content -> fade in
    return new Promise(async (resolve) => {
      el.style.transition = `opacity ${ms}ms ease`;
      el.style.opacity = 0;
      await sleep(ms);
      setContentFn();
      requestAnimationFrame(() => {
        el.style.opacity = 1;
        resolve();
      });
    });
  }

  // ---------- audio autoplay handling ----------
  const audio = document.getElementById("restAudio");
  const audioHelp = document.getElementById("audioHelp");

  async function tryPlayAudio() {
    try {
      await audio.play();
      audioHelp.hidden = true;
    } catch (e) {
      // Autoplay blocked; show a small helper button
      audioHelp.hidden = false;
    }
  }

  audioHelp.addEventListener("click", async () => {
    await tryPlayAudio();
  });

  // ---------- content sequencing ----------
  const msgEl = document.getElementById("restMessage");
  const qaWrap = document.getElementById("restQA");
  const emptyEl = document.getElementById("restEmpty");
  const qEl = document.getElementById("qaQ");
  const aEl = document.getElementById("qaA");
  const nextBtn = document.getElementById("nextBtn");

  const qas = JSON.parse(document.getElementById("qas-data").textContent || "[]")
    .filter(x => (x.prompt_answer || "").trim().length > 0);

    let qaIndex = Math.floor(Math.random() * qas.length);

    function getNextQA() {
    if (!qas.length) return null;

    const item = qas[qaIndex];
    qaIndex = (qaIndex + 1) % qas.length; // wrap to 0 after the last
    return item;
    }

  async function startSequence() {
    await tryPlayAudio();

    // 1) Welcome message: fade in, hold 8s, fade out
    await setFadeText(
      msgEl,
      "Welcome to the digital resting space of Ora mi topa mi mes.\nA space to reflect and dream about a more rested selfhood.",
      { fadeInMs: 1400, holdMs: 8000, fadeOutMs: 1400 }
    );

    // 2) Stay message: fade in and remain briefly
    msgEl.style.transition = "opacity 1200ms ease";
    msgEl.textContent = "Stay as long as you like.";
    requestAnimationFrame(() => { msgEl.style.opacity = 1; });

    await sleep(2500);

    // Then fade it out and move to Q&A
    msgEl.style.opacity = 0;
    await sleep(900);

    msgEl.textContent = "";

    // 3) Show Q&A
if (!qas.length) {
  emptyEl.hidden = false;
  fadeIn(emptyEl, 900);
  return;
}

qaWrap.hidden = false;
qaWrap.style.opacity = 0; // IMPORTANT: prevent flash before first animation

function renderQA(item) {
  qEl.textContent = item.prompt_question || "";
  aEl.innerHTML = (item.prompt_answer || "").replace(/\n/g, "<br>");
}

function playEnter() {
  qaWrap.classList.remove("is-entering", "is-exiting");
  // Force a reflow so the animation reliably restarts
  void qaWrap.offsetWidth;
  qaWrap.classList.add("is-entering");
}

function playExit() {
  qaWrap.classList.remove("is-entering", "is-exiting");
  void qaWrap.offsetWidth;
  qaWrap.classList.add("is-exiting");
}

function waitForAnimationEnd(el, fallbackMs = 950) {
  return new Promise(resolve => {
    let done = false;

    const finish = () => {
      if (done) return;
      done = true;
      el.removeEventListener("animationend", finish);
      resolve();
    };

    el.addEventListener("animationend", finish, { once: true });

    // Fallback: resolve even if animationend never fires
    setTimeout(finish, fallbackMs);
  });
}


// first QA
let current = getNextQA();
renderQA(current);
playEnter();
await waitForAnimationEnd(qaWrap);

qaWrap.classList.remove("is-entering", "is-exiting");
qaWrap.style.opacity = 1;
qaWrap.classList.add("is-drifting");

// Next button: fade out -> swap -> fade in
nextBtn.addEventListener("click", async () => {
  if (!qas.length) return;
  nextBtn.disabled = true;

  // Make sure opacity transitions are enabled
  qaWrap.classList.add("is-fading");

  // Fade out
  qaWrap.style.opacity = 0;
  await waitForTransitionEnd(qaWrap, "opacity", 900);

  // HARD hide during swap to prevent “ghost” layering on iOS
  qaWrap.style.visibility = "hidden";

  // swap content
  current = getNextQA();
  renderQA(current);

  // Force repaint before showing again
  forceRepaint(qaWrap);

  // Show + fade in
  qaWrap.style.visibility = "visible";
  qaWrap.style.opacity = 1;
  await waitForTransitionEnd(qaWrap, "opacity", 900);

  nextBtn.disabled = false;
});



  }

  startSequence();
</script>
{% endblock %}
